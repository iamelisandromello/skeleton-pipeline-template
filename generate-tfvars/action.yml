# 📄 generate-tvars.yml
# Action: Gera arquivo terraform.auto.tfvars.json com base em variáveis dinâmicas e segredos
# Objetivo: Gera arquivo terraform.auto.tfvars.json com base em variáveis dinâmicas e segredos
name: 'Generate tfvars'
description: 'Gera arquivo terraform.auto.tfvars.json com base em variáveis dinâmicas e segredos'

inputs:
  AWS_REGION:
    required: true
  PROJECT_NAME:
    required: true
  ENVIRONMENT:
    required: true
  GLOBAL_ENV_VARS_JSON:
    required: true
  ENVIRONMENTS:
    required: true
  aws_access_key_id:
    required: true
  aws_secret_access_key:
    required: true
  s3_bucket_name:
    required: true
  # NOVO INPUT: Para controlar a criação da SQS
  create_sqs_queue:
    description: "Define se a fila SQS deve ser criada (true/false)."
    required: true
    type: string # Receberá "true" ou "false" como string
    default: "true" # Mantém o comportamento padrão de criar se não for explicitamente definido

runs:
  using: "composite"
  steps:
    # 📊 Verificar o sucesso no recebimento das variáveis 
    - name: Debug variáveis de entrada na Generate tfvars
      shell: bash
      run: |
        echo "project_name=${{ inputs.PROJECT_NAME }}"
        echo "environment=${{ inputs.ENVIRONMENT }}"
        echo "s3_bucket_name=${{ inputs.s3_bucket_name }}"
        echo "aws_region=${{ inputs.AWS_REGION }}"
        echo "create_sqs_queue=${{ inputs.create_sqs_queue }}" 
        echo "---"

    # 🧾 Gerando arquivo de variáveis terraform
    - name: Gerar arquivo terraform.auto.tfvars.json
      shell: bash
      run: |
        sh -c "
          set -e
          echo \"Gerando terraform.auto.tfvars.json...\"

          # Instala jq se não estiver presente (geralmente já está em runners ubuntu-latest)
          if ! command -v jq &> /dev/null
          then
              echo \"jq não encontrado. Instalando...\"
              sudo apt-get update && sudo apt-get install -y jq
          fi

          # Debug jq version para fins de diagnóstico futuro
          echo \"jq version: $(jq --version)\"

          # Garante que o diretório 'terraform' exista antes de tentar escrever o arquivo
          mkdir -p terraform/

          # Estratégia de Arquivos Temporários:
          # Escreve o conteúdo JSON bruto dos inputs para arquivos temporários.
          echo \"${{ inputs.ENVIRONMENTS }}\" > environments_input_temp.json
          echo \"${{ inputs.GLOBAL_ENV_VARS_JSON }}\" > global_env_vars_input_temp.json
          
          # ADDED DEBUG: Verifique o conteúdo dos arquivos temporários após a escrita
          echo \"--- DEBUG: Conteúdo de environments_input_temp.json ---\"
          cat environments_input_temp.json
          echo \"--- DEBUG: Conteúdo de global_env_vars_input_temp.json ---\"
          cat global_env_vars_input_temp.json
          echo \"---------------------------------------------------\"

          # Constrói o filtro JQ como uma string literal para evitar problemas do parser YAML.
          JQ_FILTER_CONTENT=\"{\\n  environments: (\$environments_val | fromjson),\\n  global_env_vars: (\$global_env_vars_val | fromjson),\\n  s3_bucket_name: \$s3_bucket_name_val,\\n  aws_region: \$aws_region_val,\\n  project_name: \$project_name_val,\\n  environment: \$environment_val,\\n  create_sqs_queue: (\$create_sqs_queue_str | if . == \\\"true\\\" then true else false end)\\n}\"
          echo \"$JQ_FILTER_CONTENT\" > jq_filter.jq

          # ADDED DEBUG: Verifique o conteúdo do arquivo jq_filter.jq
          echo \"--- DEBUG: Conteúdo de jq_filter.jq ---\"
          cat jq_filter.jq
          echo \"------------------------------------\"

          # Executa jq lendo o filtro do arquivo e passando os argumentos.
          # Note a necessidade de escapar as aspas duplas internas que fazem parte dos valores.
          json_content=$(jq -n \
            --argfile environments_val environments_input_temp.json \
            --argfile global_env_vars_val global_env_vars_input_temp.json \
            --arg s3_bucket_name_val \"${{ inputs.s3_bucket_name }}\" \
            --arg aws_region_val \"${{ inputs.AWS_REGION }}\" \
            --arg project_name_val \"${{ inputs.PROJECT_NAME }}\" \
            --arg environment_val \"${{ inputs.ENVIRONMENT }}\" \
            --arg create_sqs_queue_str \"${{ inputs.create_sqs_queue }}\" \
            -f jq_filter.jq)

          # ADDED DEBUG: Imprime o resultado do jq antes de escrever no arquivo
          echo \"--- DEBUG: Conteúdo da variável json_content antes de escrever ---\"
          echo \"$json_content\"
          echo \"------------------------------------------\"

          echo \"$json_content\" > terraform/terraform.auto.tfvars.json

          # Limpa os arquivos temporários
          rm environments_input_temp.json global_env_vars_input_temp.json jq_filter.jq

          echo \"✅ terraform.auto.tfvars.json gerado com sucesso!\"
        "
    
    # 🕵️‍♀️ Debug do arquivo gerado
    - name: Debug - Conteúdo de terraform.auto.tfvars.json (APÓS GERAÇÃO)
      shell: bash
      run: |
        echo "📄 Conteúdo final de terraform/terraform.auto.tfvars.json:"
        cat terraform/terraform.auto.tfvars.json || echo "❌ terraform.auto.tfvars.json não encontrado."
        echo "---"

    # 🗂️ Validando acesso ao repositório na AWS
    - name: Verificar acesso ao bucket S3
      shell: bash
      run: aws s3 ls s3://${{ inputs.s3_bucket_name }}
      env:
        AWS_ACCESS_KEY_ID: ${{ inputs.aws_access_key_id }}
        AWS_SECRET_ACCESS_KEY: ${{ inputs.aws_secret_access_key }}
        AWS_REGION: ${{ inputs.AWS_REGION }}

    # 🛡️ Validando credenciais de acesso a AWS
    - name: Validar credenciais AWS (STS)
      shell: bash
      run: aws sts get-caller-identity
      env:
        AWS_ACCESS_KEY_ID: ${{ inputs.aws_access_key_id }}
        AWS_SECRET_ACCESS_KEY: ${{ inputs.aws_secret_access_key }}
        AWS_REGION: ${{ inputs.AWS_REGION }}

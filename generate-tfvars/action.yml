# ğŸ“„ generate-tvars.yml
# Action: Gera arquivo terraform.auto.tfvars.json com base em variÃ¡veis dinÃ¢micas e segredos
# Objetivo: Gera arquivo terraform.auto.tfvars.json com base em variÃ¡veis dinÃ¢micas e segredos
name: 'Generate tfvars'
description: 'Gera arquivo terraform.auto.tfvars.json com base em variÃ¡veis dinÃ¢micas e segredos'

inputs:
  AWS_REGION:
    required: true
  PROJECT_NAME:
    required: true
  ENVIRONMENT:
    required: true
  GLOBAL_ENV_VARS_JSON:
    required: true
  ENVIRONMENTS:
    required: true
  aws_access_key_id:
    required: true
  aws_secret_access_key:
    required: true
  s3_bucket_name:
    required: true
  # NOVO INPUT: Para controlar a criaÃ§Ã£o da SQS
  create_sqs_queue:
    description: "Define se a fila SQS deve ser criada (true/false)."
    required: true
    type: string # ReceberÃ¡ "true" ou "false" como string
    default: "true" # MantÃ©m o comportamento padrÃ£o de criar se nÃ£o for explicitamente definido

runs:
  using: "composite"
  steps:
    # ğŸ“Š Verificar o sucesso no recebimento das variÃ¡veis 
    - name: Debug variÃ¡veis de entrada na Generate tfvars
      shell: bash
      run: |
        echo "project_name=${{ inputs.PROJECT_NAME }}"
        echo "environment=${{ inputs.ENVIRONMENT }}"
        echo "s3_bucket_name=${{ inputs.s3_bucket_name }}"
        echo "aws_region=${{ inputs.AWS_REGION }}"
        echo "create_sqs_queue=${{ inputs.create_sqs_queue }}" 
        echo "---"

    # ğŸ§¾ Gerando arquivo de variÃ¡veis terraform
    - name: Gerar arquivo terraform.auto.tfvars.json
      shell: bash
      run: |
        set -e
        echo "Gerando terraform.auto.tfvars.json..."

        # Instala jq se nÃ£o estiver presente (geralmente jÃ¡ estÃ¡ em runners ubuntu-latest)
        if ! command -v jq &> /dev/null
        then
            echo "jq nÃ£o encontrado. Instalando..."
            sudo apt-get update && sudo apt-get install -y jq
        fi

        # Debug jq version para fins de diagnÃ³stico futuro
        echo "jq version: $(jq --version)"

        # Garante que o diretÃ³rio 'terraform' exista antes de tentar escrever o arquivo
        mkdir -p terraform/

        # EstratÃ©gia de Arquivos TemporÃ¡rios:
        # Escreve o conteÃºdo JSON bruto dos inputs para arquivos temporÃ¡rios.
        # Isso Ã© a maneira mais robusta de garantir que jq leia o JSON corretamente,
        # independentemente de como o GitHub Actions expande variÃ¡veis multi-linha.
        
        # O GitHub Actions jÃ¡ remove as aspas dos secrets JSONs automaticamente quando passados como inputs,
        # entÃ£o escrevemos o conteÃºdo como estÃ¡.
        echo "${{ inputs.ENVIRONMENTS }}" > environments_input_temp.json
        echo "${{ inputs.GLOBAL_ENV_VARS_JSON }}" > global_env_vars_input_temp.json
        
        # Debug dos arquivos temporÃ¡rios para verificar o conteÃºdo
        echo "--- Debug environments_input_temp.json ---"
        cat environments_input_temp.json
        echo "--- Debug global_env_vars_input_temp.json ---"
        cat global_env_vars_input_temp.json
        echo "---"

        # LÃª o conteÃºdo dos arquivos temporÃ¡rios para variÃ¡veis do shell.
        # Isso garante que mesmo JSONs multi-linha sejam tratados como uma Ãºnica string.
        ENVIRONMENTS_CONTENT=$(cat environments_input_temp.json)
        GLOBAL_ENV_VARS_CONTENT=$(cat global_env_vars_input_temp.json)

        # Determina o valor booleano para create_sqs_queue
        CREATE_SQS_QUEUE_BOOL=$(if [ "${{ inputs.create_sqs_queue }}" == "true" ]; then echo "true"; else echo "false"; fi)

        # ConstrÃ³i o JSON final usando printf para evitar problemas de expansÃ£o
        # e garantir que os JSONs complexos sejam inseridos como literais.
        # O '%s' em printf Ã© seguro para inserir o conteÃºdo bruto dos JSONs lidos dos arquivos.
        # O 'create_sqs_queue' Ã© inserido como "true" ou "false" booleano.
        printf -v tfvars_raw_json '{
  "aws_region": "%s",
  "project_name": "%s",
  "environment": "%s",
  "s3_bucket_name": "%s",
  "global_env_vars": %s,
  "environments": %s,
  "create_sqs_queue": %s
}' \
"${{ inputs.AWS_REGION }}" \
"${{ inputs.PROJECT_NAME }}" \
"${{ inputs.ENVIRONMENT }}" \
"${{ inputs.s3_bucket_name }}" \
"$GLOBAL_ENV_VARS_CONTENT" \
"$ENVIRONMENTS_CONTENT" \
"$CREATE_SQS_QUEUE_BOOL"

        # Debug da string JSON bruta antes de passar para o jq
        echo "--- Debug: JSON Bruto ConstruÃ­do ---"
        echo "$tfvars_raw_json"
        echo "---"

        # Finalmente, usa jq para formatar (pretty-print) e validar o JSON.
        # Se houver um erro de sintaxe aqui, jq irÃ¡ falhar e o erro serÃ¡ claro.
        final_json=$(echo "$tfvars_raw_json" | jq '.')

        # Verifica se o jq conseguiu processar o JSON (ou seja, se a sintaxe estava correta)
        if [ $? -ne 0 ]; then
            echo "âŒ Erro: O JSON construÃ­do estÃ¡ malformado. Verifique os valores das secrets."
            echo "ConteÃºdo JSON malformado:"
            echo "$tfvars_raw_json"
            exit 1
        fi

        echo "$final_json" > terraform/terraform.auto.tfvars.json

        # Limpa os arquivos temporÃ¡rios
        rm environments_input_temp.json global_env_vars_input_temp.json

        echo "âœ… terraform.auto.tfvars.json gerado com sucesso!"
    
    # ğŸ•µï¸â€â™€ï¸ Debug do arquivo gerado
    - name: Debug - ConteÃºdo de terraform.auto.tfvars.json (APÃ“S GERAÃ‡ÃƒO)
      shell: bash
      run: |
        echo "ğŸ“„ ConteÃºdo final de terraform/terraform.auto.tfvars.json:"
        cat terraform/terraform.auto.tfvars.json || echo "âŒ terraform.auto.tfvars.json nÃ£o encontrado."
        echo "---"

    # ğŸ—‚ï¸ Validando acesso ao repositÃ³rio na AWS
    - name: Verificar acesso ao bucket S3
      shell: bash
      run: aws s3 ls s3://${{ inputs.s3_bucket_name }}
      env:
        AWS_ACCESS_KEY_ID: ${{ inputs.aws_access_key_id }}
        AWS_SECRET_ACCESS_KEY: ${{ inputs.aws_secret_access_key }}
        AWS_REGION: ${{ inputs.AWS_REGION }}

    # ğŸ›¡ï¸ Validando credenciais de acesso a AWS
    - name: Validar credenciais AWS (STS)
      shell: bash
      run: aws sts get-caller-identity
      env:
        AWS_ACCESS_KEY_ID: ${{ inputs.aws_access_key_id }}
        AWS_SECRET_ACCESS_KEY: ${{ inputs.aws_secret_access_key }}
        AWS_REGION: ${{ inputs.AWS_REGION }}
